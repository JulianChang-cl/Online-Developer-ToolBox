# Research: HTML & URL Encoding Implementation

**Feature**: 006-html-url-encoding  
**Date**: 2025-10-31  
**Status**: Complete

---

## 1. HTML Entity Encoding

### Decision: Essential Entity Set

**Chosen Approach**: Encode only essential HTML entities for XSS prevention

**Essential Entities** (mandatory):
```typescript
const HTML_ENTITIES: Record<string, string> = {
  '&': '&amp;',   // MUST encode first to avoid double-encoding
  '<': '&lt;',    // Prevents tag injection
  '>': '&gt;',    // Prevents tag injection
  '"': '&quot;',  // Prevents attribute injection
  "'": '&#39;'    // Prevents attribute injection (single quotes)
}
```

**Rationale**:
- These 5 characters are sufficient to prevent XSS in HTML contexts
- Named entities are more readable than numeric entities
- `&#39;` used instead of `&apos;` (not recognized in older HTML4)
- Covers both element content and attribute contexts

**Alternatives Considered**:
1. ‚ùå Encode all non-ASCII as numeric entities (`&#NNNN;`)
   - Rejected: Unnecessary, modern browsers handle UTF-8
   - Would make output unreadable for international text
2. ‚ùå Use all 252 HTML5 named entities
   - Rejected: Overkill, adds complexity, not needed for XSS prevention
3. ‚ùå Context-aware encoding (element vs attribute)
   - Rejected: Too complex, single pass with these 5 covers all contexts

### Decision: Decoding Strategy

**Chosen Approach**: Support both named and numeric entities

**Decoding Map**:
```typescript
const NAMED_ENTITIES: Record<string, string> = {
  'lt': '<',
  'gt': '>',
  'amp': '&',
  'quot': '"',
  'apos': "'",
  'nbsp': '\u00A0',  // Common entity, include for convenience
  // Add more as needed
}

// Numeric entity regex: &#60; or &#x3C;
const NUMERIC_ENTITY_REGEX = /&#(\d+);|&#x([0-9A-Fa-f]+);/g
```

**Rationale**:
- Named entities are common in hand-written HTML
- Numeric entities (decimal and hex) are generated by tools
- Support both for maximum compatibility
- Invalid entities pass through unchanged (graceful degradation)

**Edge Cases**:
1. **Nested entities**: `&amp;lt;` ‚Üí `&lt;` ‚Üí `<` (decode once only)
2. **Malformed entities**: `&lt` (missing semicolon) ‚Üí leave as-is
3. **Unknown entities**: `&unknown;` ‚Üí leave as-is
4. **Numeric out of range**: `&#9999999;` ‚Üí handle with `String.fromCodePoint()` bounds check

---

## 2. URL Encoding (RFC 3986)

### Decision: RFC 3986 Compliance

**Chosen Approach**: Use `encodeURIComponent()` with post-processing

**Unreserved Characters** (MUST NOT encode):
```typescript
// A-Z, a-z, 0-9, -, ., _, ~
const UNRESERVED = /[A-Za-z0-9\-\._~]/
```

**Reserved Characters** (context-dependent):
```typescript
// : / ? # [ ] @ ! $ & ' ( ) * + , ; =
// Encode in query strings, may keep in URIs depending on context
```

**Implementation**:
```typescript
function encodeURL(input: string): string {
  // Use native encodeURIComponent (handles UTF-8 correctly)
  let encoded = encodeURIComponent(input)
  
  // RFC 3986 fix: encodeURIComponent encodes !'()* unnecessarily
  encoded = encoded
    .replace(/%20/g, '%20')  // Keep %20 for spaces (not +)
    .replace(/[!'()*]/g, (c) => '%' + c.charCodeAt(0).toString(16).toUpperCase())
  
  return encoded
}
```

**Rationale**:
- `encodeURIComponent()` is optimized and handles UTF-8 correctly
- RFC 3986 is more restrictive than the older RFC 2396
- `%20` for spaces (not `+`) per RFC 3986
- Uppercase hex digits per convention

**Alternatives Considered**:
1. ‚ùå Manual byte-by-byte encoding
   - Rejected: Complex UTF-8 handling, reinventing the wheel
2. ‚ùå `encodeURI()` instead of `encodeURIComponent()`
   - Rejected: Doesn't encode enough characters (e.g., `=`, `&`)
3. ‚ùå Support both `%20` and `+` for spaces
   - Rejected: RFC 3986 specifies `%20`, `+` is query string specific

### Decision: Decoding Error Handling

**Chosen Approach**: Try native `decodeURIComponent()`, fallback gracefully

**Implementation**:
```typescript
function decodeURL(input: string): string {
  try {
    return decodeURIComponent(input)
  } catch (error) {
    // Invalid percent sequence, return original or partial decode
    // Example: "valid%20text%ZZmore" ‚Üí decode valid parts
    return input.replace(/%([0-9A-Fa-f]{2})/g, (match, hex) => {
      return String.fromCharCode(parseInt(hex, 16))
    })
  }
}
```

**Edge Cases**:
1. **Invalid hex**: `%ZZ` ‚Üí pass through as-is
2. **Incomplete sequence**: `%2` at end ‚Üí pass through
3. **Mixed valid/invalid**: Decode valid sequences, keep invalid
4. **Malicious input**: `%00` (null byte) ‚Üí decode to `\0` (let browser handle)

**Rationale**:
- Graceful degradation better than throwing errors
- Partial decode helps debugging
- Browser handles null bytes and control characters safely

---

## 3. Existing Tool Patterns

### Layout Pattern Analysis

**Base64EncodeTool.tsx** (reference implementation):
```tsx
<div className="grid gap-4 h-full min-w-0 p-4" 
     style={{ gridTemplateColumns: '1fr 2fr 2fr' }}>
  {/* Column 1: Settings */}
  <ToolOptions 
    hasOptions={true}
    optionsComponent={Base64EncodeOptions}
    options={localOptions}
    onOptionChange={handleOptionChange}
  />
  
  {/* Column 2: Input */}
  <div className="flex flex-col gap-3 min-w-0 min-h-0">
    <InputField 
      id="base64-encode-input"
      label="Input Text"
      value={localInput}
      onChange={(value) => setLocalInput(value)}
      placeholder="Enter text to encode..."
    />
    {!autoUpdate && <button onClick={handleEncode}>Encode</button>}
  </div>
  
  {/* Column 3: Output */}
  <div className="flex flex-col gap-3 min-w-0 min-h-0">
    <OutputField
      id="base64-encode-output"
      label="Base64 Encoded"
      value={output}
      showEmpty={!isProcessing && !output}
    />
    {output && (
      <div className="flex gap-2">
        <CopyButton textToCopy={output} />
        <ShareButton toolId={TOOL_ID} input={localInput} options={localOptions} />
      </div>
    )}
  </div>
</div>
```

**Key Patterns**:
1. **Grid Layout**: `gridTemplateColumns: '1fr 2fr 2fr'` (20% / 40% / 40%)
2. **ToolOptions**: Wrapper with `optionsComponent` prop
3. **Auto-Update**: 200ms debounce with `useEffect`
4. **Always-Visible Output**: `showEmpty` prop shows placeholder
5. **State Management**: `localInput` and `localOptions` synced with context
6. **Auto-Clear**: Empty input clears output

### Auto-Update Implementation

```typescript
// From Base64EncodeTool.tsx
useEffect(() => {
  if (!autoUpdate) return
  
  const timer = setTimeout(() => {
    if (localInput.trim() === '') {
      setOutput('')
      return
    }
    
    // Perform encoding
    const result = service.encode(localInput, localOptions)
    setOutput(result)
  }, 200)  // 200ms debounce
  
  return () => clearTimeout(timer)
}, [localInput, localOptions, autoUpdate])
```

### Sidebar State Management

**From `src/hooks/useSidebarState.ts`**:
```typescript
const DEFAULT_STATE: SidebarState = {
  base64: false,
  base16: false,
  base32: false,
  json: false,
  // Need to add:
  html: false,
  url: false
}
```

**Tool Registration** (from `src/tools/index.ts`):
```typescript
export const TOOL_GROUPS: ToolGroup[] = [
  {
    id: 'base64',
    name: 'Base64',
    items: [
      { id: 'base64-encode', name: 'Encode' },
      { id: 'base64-decode', name: 'Decode' }
    ]
  },
  // ... similar for base16, base32, json
  // Need to add:
  {
    id: 'html',
    name: 'HTML',
    items: [
      { id: 'html-encode', name: 'Encode' },
      { id: 'html-decode', name: 'Decode' }
    ]
  },
  {
    id: 'url',
    name: 'URL',
    items: [
      { id: 'url-encode', name: 'Encode' },
      { id: 'url-decode', name: 'Decode' }
    ]
  }
]
```

---

## 4. Performance Considerations

### Expected Performance

**HTML Encoding**:
- Algorithm: O(n) single pass with character lookup
- 10KB input: ~5-10ms (string replacement is fast)
- No regex (direct character iteration preferred)

**URL Encoding**:
- Algorithm: O(n) via native `encodeURIComponent()`
- 10KB input: ~2-5ms (native implementation optimized)
- Decoding similar performance

**Optimization Strategies**:
1. **Avoid regex** where simple loops suffice (HTML encoding)
2. **Use native functions** (URL encoding)
3. **Single pass**: Don't iterate multiple times
4. **Avoid string concatenation**: Use array join or replace
5. **Test at scale**: 10KB minimum, 100KB stretch goal

### Performance Test

```typescript
// Contract test requirement
it('should encode 10KB input in <50ms', () => {
  const largeInput = 'test'.repeat(2500)  // 10KB
  
  const start = performance.now()
  const result = htmlEncoder.encode(largeInput)
  const duration = performance.now() - start
  
  expect(duration).toBeLessThan(50)
  expect(result.length).toBeGreaterThan(largeInput.length)
})
```

---

## 5. Edge Case Catalog

### HTML Encoding Edge Cases

| Input | Expected Output | Rationale |
|-------|----------------|-----------|
| `<script>alert('XSS')</script>` | `&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;` | Full XSS prevention |
| `"Hello"` | `&quot;Hello&quot;` | Attribute safety |
| `<img src="x" onerror='alert(1)'>` | `&lt;img src=&quot;x&quot; onerror=&#39;alert(1)&#39;&gt;` | Prevents attribute injection |
| `‰Ω†Â•Ω ‰∏ñÁïå` | `‰Ω†Â•Ω ‰∏ñÁïå` | Unicode pass-through |
| `üöÄ Emoji` | `üöÄ Emoji` | Emoji pass-through |
| Empty string | Empty string | No-op |
| `&amp;` | `&amp;amp;` | Encode existing entities |

### HTML Decoding Edge Cases

| Input | Expected Output | Notes |
|-------|----------------|-------|
| `&lt;div&gt;` | `<div>` | Named entities |
| `&#60;div&#62;` | `<div>` | Numeric decimal |
| `&#x3C;div&#x3E;` | `<div>` | Numeric hex |
| `&lt;` | `&lt;` | Malformed (missing semicolon) |
| `&unknown;` | `&unknown;` | Unknown entity pass-through |
| `&amp;lt;` | `&lt;` | Decode once only |
| `&#9999999;` | Handle gracefully | Out of range |

### URL Encoding Edge Cases

| Input | Expected Output | Rationale |
|-------|----------------|-----------|
| `hello world` | `hello%20world` | Space encoding |
| `name=value` | `name%3Dvalue` | Reserved char |
| `user@domain.com` | `user%40domain.com` | @ encoding |
| `‰Ω†Â•Ω` | `%E4%BD%A0%E5%A5%BD` | UTF-8 multi-byte |
| `üöÄ` | `%F0%9F%9A%80` | Emoji (4 bytes UTF-8) |
| `test-_~.txt` | `test-_~.txt` | Unreserved not encoded |
| Empty string | Empty string | No-op |

### URL Decoding Edge Cases

| Input | Expected Output | Notes |
|-------|----------------|-------|
| `hello%20world` | `hello world` | Valid percent |
| `test%ZZ` | `test%ZZ` | Invalid hex pass-through |
| `test%2` | `test%2` | Incomplete sequence |
| `valid%20%ZZmore` | `valid %ZZmore` | Mixed valid/invalid |
| `%00` | `\0` | Null byte (decode, browser handles) |
| Empty string | Empty string | No-op |

---

## 6. Testing Strategy

### Contract Test Structure

**Per Service** (8 tests minimum):
1. ‚úÖ Basic encoding (common characters)
2. ‚úÖ Decoding reverses encoding (idempotent)
3. ‚úÖ Edge case: Empty input
4. ‚úÖ Edge case: Special characters
5. ‚úÖ Edge case: Unicode/emoji
6. ‚úÖ Edge case: Invalid input (decoding)
7. ‚úÖ Edge case: Large input (10KB)
8. ‚úÖ Performance: <50ms for 10KB

**Component Tests** (optional, 4 tests per tool):
1. Auto-update triggers on input change
2. Manual button works when auto-update off
3. Output always visible (showEmpty)
4. Copy/Share buttons functional

### Test-First Workflow Example

```typescript
// Step 1: Write failing test (RED)
describe('HTML Encoder', () => {
  it('should encode < > & " \' to entities', () => {
    const input = `<script>alert("XSS")</script>`
    const expected = `&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;`
    
    const result = htmlEncoder.encode(input)
    
    expect(result).toBe(expected)
  })
})

// Step 2: Implement minimal code (GREEN)
export const htmlEncoder = {
  encode(input: string): string {
    return input
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
  }
}

// Step 3: Refactor (REFACTOR)
// Extract entity map, add comments, optimize
```

---

## 7. Implementation Checklist

### Services (TDD Required)

- [ ] `html-encoder.ts`: encode() function
- [ ] `html-encoder.ts`: decode() function
- [ ] `html-encoder.ts`: validate() function
- [ ] `url-encoder.ts`: encode() function
- [ ] `url-encoder.ts`: decode() function
- [ ] `url-encoder.ts`: validate() function
- [ ] Contract tests: 32+ tests total
- [ ] Performance tests: <50ms for 10KB

### Components (Follow Pattern)

- [ ] `HTMLEncodeTool.tsx`: 3-column layout
- [ ] `HTMLDecodeTool.tsx`: 3-column layout
- [ ] `URLEncodeTool.tsx`: 3-column layout
- [ ] `URLDecodeTool.tsx`: 3-column layout
- [ ] ToolOptions with Auto-Update toggle
- [ ] InputField with proper labels
- [ ] OutputField always visible
- [ ] CopyButton + ShareButton

### Integration

- [ ] Register 4 tools in `src/tools/index.ts`
- [ ] Add HTML and URL groups to TOOL_GROUPS
- [ ] Update DEFAULT_SETTINGS for new tools
- [ ] Add routing in `App.tsx` (4 routes)
- [ ] Update `useSidebarState.ts` (html: false, url: false)
- [ ] Update `.github/copilot-instructions.md`

### Quality Gates

- [ ] All contract tests pass (32+)
- [ ] TypeScript compilation: 0 errors
- [ ] Lint: 0 errors
- [ ] Production build: Success
- [ ] Browser testing: Layout consistent
- [ ] Performance: <50ms verified

---

## 8. Decisions Summary

| Decision Point | Chosen Approach | Rationale |
|----------------|-----------------|-----------|
| HTML entities | 5 essential entities (`<>&"'`) | XSS prevention, simplicity |
| Named vs numeric | Named for encoding, both for decoding | Readability vs compatibility |
| Unicode handling | Pass through (no encoding) | UTF-8 support, modern browsers |
| URL encoding | `encodeURIComponent()` + RFC 3986 fix | Native optimization, correctness |
| Space encoding | `%20` (not `+`) | RFC 3986 compliance |
| Error handling | Graceful degradation (partial decode) | User-friendly, debugging aid |
| Layout pattern | Copy Base64EncodeTool exactly | UI consistency (Constitution III) |
| Testing approach | Contract-first TDD | Constitution II (Test-First Mandatory) |

---

## Next Steps

1. ‚úÖ Research complete
2. ‚û°Ô∏è **Proceed to Phase 1**: Generate `data-model.md` and `contracts/`
3. Write contract tests (RED)
4. Implement services (GREEN)
5. Refactor and optimize (REFACTOR)
6. Create components following layout pattern
7. Integrate with sidebar and routing
8. Verify quality gates

---

**Status**: ‚úÖ Complete  
**All NEEDS CLARIFICATION items**: Resolved  
**Ready for**: Phase 1 (Data Model & Contracts)
